<library>
<include href="lzosutils/lib"/>
<include href="xpath/lib"/>
<script src="md5.js"/>

<class name = 'block' extends = 'node'>
	<attribute name = 'text' type = 'text'/>
	<attribute name = 'query' type = 'expression'/>
	<handler name = 'oninit'><![CDATA[
		setAttribute('text', this.text.replace('&apos;', "'", 'g').replace('&quot;', '"', 'g'));
		console.log(this.text);
		this.setAttribute('query', XPath.parse(this.text));
		if (this.query) this.setAttribute('text', null);
		// TODO: set up dependency on query and variables
	]]></handler>
</class>

<class name = 'mixt_for' extends = 'block'>
	<attribute name = 'each' type = 'string' required = 'true'/>
	<method name = 'bind' args = 'node, mod'>
		if (this.each == "target") {
			mod.lastTarget = node;
		} else if (this.each.startsWith("$")) {
			mod.vars[this.each] = node;
		} else {
			console.error("'for' block unable to bind '" + this.each + "'");
		}
		return mod;
	</method>
</class>

<class name = 'mixt_insert' extends = 'block'>
</class>

<class name = 'mixt_rule' extends = 'node'>
	<attribute name = 'xml_id' type = 'string' required = 'true'/>
	<attribute name = 'description' type = 'string' required = 'false'/>
	<method name = 'init'>
		this.mods = {};
	</method>
	<method name = 'recompute' args = 'env'>
		var computedMods = {};
		computedMods[this.xmlid] = new Mod(this.xmlid);
		this.subnodes.forEach(function(block) {
			if (!block.compute) return;
			derivedMods = {};
			computedMods.forEach(function(mod) {
				derivedMods.append(block.compute(mod, env));
			});
			computedMods = derivedMods;
		});
		for (var key in this.mods) if (!(key in computedMods)) this.mods[key].withdraw();
		for (var key in computedMods) if (!(key in this.mods)) computedMods[key].apply();
		this.mods = computedMods;
	</method>
</class>

<class name = 'mixt_rules' extends = 'node'>
	<method name = 'recompute' args = 'env'>
		this.subnodes.forEach(function(rule) {
			if (rule.recompute(env)) changesMade = true;
		});
	</method>
</class>

<class name = 'mod_affected' extends = 'node'>
	<attribute name = 'refid' type = 'string' required = 'true'/>
</class>

<class name = 'mod_dependency' extends = 'node'>
	<attribute name = 'doc' type = 'string' required = 'false'/>
	<attribute name = 'kind' type = 'string' required = 'false'/>
</class>

<class name = 'mod_reference' extends = 'node'>
	<attribute name = 'refid' type = 'string' required = 'true'/>
	<attribute name = 'doc' type = 'string' required = 'false'/>
</class>

<class name = 'mod_order' extends = 'node'>
	<attribute name = 'refid' type = 'string' required = 'true'/>
	<attribute name = 'doc' type = 'string' required = 'false'/>
</class>

<class name = 'mod_mod' extends = 'node'>
	<attribute name = 'xml_id' type = 'string' required = 'false'/>
	<attribute name = 'stage' type = 'number' required = 'true'/>
</class>

<class name = 'mod_mods' extends = 'node'>
	<attribute name = 'xml_id' type = 'string' required = 'true'/>
	<attribute name = 'rule' type = 'string' required = 'true'/>
</class>

<class name = 'mod_modstore' extends = 'node'>
</class>

<class name = 'MixtEngine' extends = 'node'>
	<method name = 'recompute' args = 'env'>
		var changesMade;
		do {
			changesMade = false;
			this.subnodes[0].recompute(env);
		} while (changesMade);
	</method>
</class>

</library>
